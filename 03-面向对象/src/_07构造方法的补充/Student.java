package _07构造方法的补充;
import _07构造方法的补充.Person;

public class Student extends Person {
	int no;
	
	public Student() {
		/*
		 * 补充1：子类的构造方法必须先调用父类的构造方法，然后再执行其它代码
		 * 也就是说子类的构造方法里第一句代码必须得是调用父类的构造方法
		 * 
		 * 其实很多语言里都是这么设计的，目的就是为了保证子类继承自父类的那些属性能够被正常初始化
		 * 这也就意味着一个对象的内存中，来自父类的属性会存储在它内存的前面
		 * 
		 * 补充2：但实际开发中我们很少会主动去写“调用父类的构造方法这一句代码”（想想Dart里一个定义一个
		 * Widget，我们不也是直接写它自己构造方法嘛，很少会去写“super(key: key)”这样的代码），因为编
		 * 译器会自动帮我们插入一条这样的语句，但需要注意的是仅仅会插入一条“调用父类的无参构造方法”，注意
		 * 是“父类的无参构造方法”，那万一父类里只有全能构造方法没有无参构造方法怎么办？那就得我们自己显性
		 * 地去插入一条“调用父类的全能构造方法”的代码了。
		 * 
		 * 补充3：在是否需要自定义构造函数这块，我感觉Java和OC、Swift比价像，那就是不要去自定义，建议用系统
		 * 自带的无参构造方法就好了，创建出对象来再一个一个给属性赋值就行了，当然也可以自定义构造方法去要求
		 * 别人给你传值给属性赋值，但偏好于不自定义。而Dart里面，Model啥的我也偏好于不自定义构造方法，因为
		 * Model里的属性我们一般都是定义成可选类型，那已经默认初始化成null了，就没必要再去搞初始化方法给它们
		 * 默认值了，但是Widget就需要自定义构造方法（并且编译器会自动调用super），因为Widget里面的参数我们
		 * 一般都不会定义成可选类型，而都是一些具体的类型，它们要么已经初始化好了，要么就得required外界必须传
		 * 一个值进来，我们才好绘制指定的UI效果。
		 */
//		super();
		super(18);
		
		System.out.println("Student");
	}
}
