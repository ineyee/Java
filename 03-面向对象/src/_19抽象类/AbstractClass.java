package _19抽象类;

/*
 * 在说抽象类之前，我们先说一下抽象方法。
 * 
 * 一、那什么是抽象方法呢？被abstract关键字修饰的方法就是抽象方法，
 * 抽象方法设计的初衷就是为了让别人来重写的。
 * 
 * 
 * 二、抽象方法有如下几个特点：
 * 1、只能定义在抽象类或接口中
 * 2、只能有方法声明，不能有方法实现（即参数列表后面不能有大括号，只能直接是分号）
 * 3、不能定义成private权限（public、protected、无修饰符都可以，因为private权限
 * 是只有自己这个类里面能使用，而抽象方法本身是没有实现的，设计的目的就是让别人去实现，
 * 那定义成private是违反抽象方法的设计初衷的，所以不能用private修饰）
 * 4、只能是实例方法，不能是类方法（因为Java里类方法只能继承不能重写，所以如果抽象方法
 * 搞成类方法也违反了抽象方法的设计初衷）
 */

/*
 * 一、那什么是抽象类呢？被abstract关键字修饰的类就是抽象类，
 * 抽象类设计的初衷就是为了当父类堆积一些公共代码、让别人来继承它的。
 * 
 * 
 * 二、抽象类有如下几个特点：
 * 1、抽象类是不能直接被实例化的
 * 2、可以定义抽象方法
 * 3、子类必须实现抽象父类里所有的抽象方法（除非这个子类自己也是个抽象类）
 * 4、抽象类也可以像普通类那样定义实例成员和类成员，也就是说普通类能干的事抽象类也都能干，也就是说
 * 抽象类就是在普通类的基础上增加了能定义抽象方法这个功能，当然减少了被实例化这个功能
 * 
 * 
 * 三、抽象类的使用场景：
 * 1、如果很多个类里面有很多重复的东西————比如重复的属性、方法等，那我们就可以考虑定义一个父类出来，
 * 把这些重复的属性和方法抽取到父类里。那你可能会问如果仅仅是这样的话，这个父类是个普通的父类就行了，
 * 没必要搞成抽象类啊，是的，在OC和Swift里面是没有抽像类这种概念的，所以这个抽取父类的操作就仅仅会
 * 止步于简单地抽取成个普通的父类，也就是说止步于此也是没什么大问题的
 * 2、但是如果父类只是一个普通的父类，它有两个不太好的地方：
 * （1）这个父类可以被直接实例化，但很多时候这个父类是不应该被实例化的，因为这个父类真得是个很抽象的
 * 东西啊，它的实例没有任何意义，一会我们会举例子
 * （2）父类里如果有一些必须被子类实现的方法、不实现的话功能就无法正常运转，可是普通的父类又无法要求
 * 子类必须重写它的某些方法，那就得完全靠程序员来保证这些必须实现的方法都实现了，这就存在不实现的风险
 * 
 * 但是如果我们在“止步于此”的基础上再进一步，把那个普通的父类升级成为一个抽象类，就可以顺利解决这两个问题了：
 * （1）抽象类不能被直接实例化，所以如果有哪个组员写法不规范，把抽象类实例化了，那编译器就会报错
 * （2）我们可以把那些子类必须实现的方法定义成抽象方法，这样子类一旦没实现，编译器就会报错，而不用我们程序员
 * 自己去担心这回事
 * 3、所以总得来说抽象类的使用场景应该是这样的：
 * 第一步：如果很多个类里面有很多重复的东西————比如重复的属性、方法等，那我们就可以考虑定义一个父类出来，
 * 把这些重复的属性和方法抽取到父类里
 * 第二步：我们再考虑一下这个父类本身有没有被实例化的意义，如果没有那就果断把父类升级为抽象类，如果有就止步于此
 * 第三步：当我们已经把一个父类升级为抽象类之后，再进一步，那就是它里面必须被子类实现的方法搞成抽象方法，这样子类
 * 是否实现交给编译器去帮我们判断，因为我们自己很容易漏掉实现，从而导致功能缺失
 * 
 * 
 * 四、接下来举一个我们项目里使用到抽象类的场景：
 * 1、我们的白板上面可以绘制矩形（RectangleElement）、圆形（CircleElement）两种图形，
 * 同时还能上传图片（PictureElement）、PDF（PdfElement）两种文件
 * 2、第一步：考虑到两种图形都有左上角点p1和右下角点p2两个重复的属性，还有获取可视区域getVisibleArea这个重复的方法，
 * 于是我们为它们两个定义了一个父类叫图形元素（GraphicsElement），然后考虑到两种文件也都有上角点p1和右下角点p2
 * 两个重复的属性，还有获取可视区域getVisibleArea这个重复的方法，于是我们为它们两个定义了一个父类叫文件元素（FileElement），
 * 进而考虑到图形元素（GraphicsElement）和文件元素（FileElement）都有左上角点p1和右下角点p2两个重复的属性，
 * 还有获取可视区域getVisibleArea这个重复的方法，于是我们为两个定义了一个父类叫基类元素（BaseElement）
 * 3、第二步：考虑到基类元素（BaseElement）、图形元素（GraphicsElement）和文件元素（FileElement）都只是个
 * 抽象的概念，没有任何实例化的必要，于是我们把它们三个都搞成抽象类，而其它4个类则是普通的类
 * 4、第三步：考虑到获取可视区域getVisibleArea方法是必须让子类实现的————因为子类不实现我们就无法判定触摸的点是否在元素内部，
 * 这个功能就无法正常运转了，所以我们把这个方法搞成了抽象方法
 * 5、回过头来想想这种实现方法比起在GraphicsElement里搞个枚举来决定是什么图形、在FileElement搞个枚举来决定是什么文件、
 * 并且直接实例化GraphicsElement和FileElement的实现方法写出来的代码肯定更加清晰、别人更容易看懂
 */

// 抽象类
public abstract class AbstractClass {
	// 抽象方法
	public abstract void abstractMethod1();
	public abstract void abstractMethod2(int num1);
	public abstract void abstractMethod3(int num1, int num2);
}
