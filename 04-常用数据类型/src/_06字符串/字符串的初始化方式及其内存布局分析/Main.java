package _06字符串.字符串的初始化方式及其内存布局分析;

public class Main {
	public static void main(String[] args) {
		test1();
	}
	
	/*
	 * 字符串的初始化方式
	 */
	public static void test1() {
		/*
		 * 1、用字面量初始化
		 * 
		 * 所有字符串字面量（比如“123”、“abc”）都是String类的实例，你可以简单地理解为
		 * 编译器自动帮我们new了一个String的对象出来，然后把"123"这个值交给了这个对象的value属性，
		 * 但严格来说并不是这么简单，往下看就能知道区别。所以我们可以直接把一个String指针
		 * 指向一个字符串字面量
		 * 
		 */
		String str1 = "123"; 
		String str2 = "123";
		/*
		 * true，代表str1和str2其实指向的是同一个对象，接下来我们从内存的角度分析一下为什么会返回true
		 * 
		 * （1）首先我们要知道无论什么语言大概都差不多是这个样子：
		 * 一个字符串对象通常是存储在堆区的，它的内存中会存储很多东西，其中有8个字节就是用来存储它的一个属性value的值的，
		 * 而这个属性value的值就是我们通常写出来的"123"、"abc"这种字面量
		 * （2）然后我们知道内存的五大分区里有个常量区
		 * （3）然后str1是个局部变量，它存储在栈区
		 * （4）然后编译器每当遇到“用字面量初始化字符串”这种方式时，它不是直接去堆区创建一个字符串对象，而是先去常量区看看，如果
		 * 发现常量区里有某个字符串对象value属性的值跟字面量"123"一样，那就直接返回这个字符串对象，否则才会创建一个字符串对象，
		 * 并把这个字面量"123"交给这个字符串对象的value属性来存储，并直接把这个字符串对象存储在常量区，也就是说通过字面量创建出来
		 * 的字符串对象不是存储在堆区的，而是存储在常量区
		 * （5）所以str1 = "123"的时候，是在常量区新建了一个字符串对象
		 * （6）而str2 = "123"的时候，是直接把常量区value属性的值为“123”的字符串对象的地址给了str2
		 * （7）所以str1和str2存储的其实是同一个常量区的地址，所以才打印了true
		 * 
		 * 
		 * 至此我们不妨再回顾一下常量区存储的是什么东西。
		 * 但凡由字面量初始化出来的东西、不管是int、double、String、Integer等都存储在常量区，我们也把这些东西相应
		 * 的称之为整型常量、浮点型常量、字符串常量，不过我们需要知道的是字符串常量指的不是那个字面量"123"，
		 * 而是指一个字符串对象、只不过这个字符串对象value属性的值是字面量"123"而已，而int类型常量不是引用类型嘛，
		 * 所以不存在对象之说，所以指的可能直接就是某块内存里的值————字面量10这样。综上，常量区存储的
		 * 是整型常量、字符串常量等常量，所谓字符串常量是一个字符串对象，Integer整型常量也是一个整型对象，而int整型
		 * 常量就是一个值。
		 * 
		 * 顺带我们不妨再回顾一下字面量、常量、变量是什么。
		 * （1）所谓字面量其实就是我们可以直接写出来的东西，如bool类型的字面量true、false，
		 * int类型的字面量10、11，double类型的字面量12.34，字符串类型的字面量"123"、"abc"等，
		 * 字面量通常出现在等号的右边，用来赋值给一个常量或变量。
		 * （2）而常量是指赋值后不能再改变的量。
		 * （3）而变量是指赋值后还能再改变的量。
		 * 
		 *	String str = "123"; // a是变量，"123"是字面量
		 *	static final String STR = "123"; // STR是常量，"123"是字面量
		 *
		 * 字面量本身并不存储在任何内存中，它只是语法提供给我们的一个快速表达特定数据的语法糖而已，它必须
		 * 有变量或常量这种宿主才能存储在某些内存中，而变量和常量是真正占内存的。比如说局部变量str存储在栈内存中，
		 * 它指向的那个字符串对象存储在常量区，所以"123"这个字面量就寄生在这个字符串对象中（value属性对应的那8个
		 * 字节的内存中）而存储在堆内存中，STR更不用说了，它本身存储在静态全局区，然后肯定也指向的是常量区的一个字符串对象，
		 * 由此可见常量指向的对象可定存储在常量区，变量指向的对象只要是通过字面量初始化的也存储在常量区、否则才存储在堆区。
		 */
		System.out.println(str1 == str2); // true
		
		String str3 = new String("123"); 
		String str4 = new String("123"); 
		/*
		 * 很显然返回false，因为str2指向的是常量区的一个字符串对象
		 * 而str3指向的是堆区的一个字符串对象，那两者的内存地址肯定不一样嘛,
		 * 当然你要是拿equals来判断就返回false了，因为虽然两个对象在不同的内存分区，
		 * 但它们的value是一样的"123"
		 */
		System.out.println(str2 == str3); // false
		/*
		 * 很显然返回false，因为str3和str4虽然指向的对象都在堆区，但是大家都分别new
		 * 的是两个独立的字符串对象嘛，内存地址自然不一样
		 */
		System.out.println(str3 == str4); // false
		
		
		/*
		 * 字符串的拼接操作并不是改变了原来对象的值，而是新建了一个对象“123456”，并让str1指向了这个新对象“123456”
		 */
		str1 += "456";
	}
}
